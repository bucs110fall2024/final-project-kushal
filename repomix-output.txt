This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-30T07:44:34.858Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/desktop.ini
assets/desktop.ini
assets/font/desktop.ini
assets/graphics/desktop.ini
assets/graphics/Player/desktop.ini
assets/graphics/snake/desktop.ini
assets/sounds/desktop.ini
desktop.ini
levels/desktop.ini
levels/level1.py
levels/level2.py
README.md
src/bush.py
src/desktop.ini
src/diamond.py
src/fire.py
src/game.py
src/maze_data.py
src/maze.py
src/player.py
src/snake.py
src/wall.py

================================================================
Repository Files
================================================================

================
File: .github/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/font/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/graphics/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/graphics/Player/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/graphics/snake/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/sounds/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: levels/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: levels/level1.py
================
maze_data = [    # 26 x 21
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXBBDBBBXXXXDBBBBDBBBBDX",
    "XXXBBBBDDBXXXXDD   X   DDX",
    "XXXVBBDXH  XXXXDD     DDXX",
    "XXX BBBDBBBXXXXXDBBBBBDXXX",
    "XXX BXBBBBBXXXXXXF    XXXX",
    "XXX BBBBXBBBBBBBXX   XXXXX",
    "XXBDBBBBBBBXXXXBXXX XXXXXX",
    "XXBXBBXXXXXXXXXBXXX XXXXXX",
    "XXBBBBBBBBBBBBXBBBB    KXX",
    "XXXXBBBBXXXXXDXXXXXXXXXXXX",
    "XXXXXXXXXXXXX BBBBBBBBBXXX",
    "XXXXXXXXXXXXXV          XX",
    "XXXXXXXXXXXXX XXF        X",
    "XXXXXXXDDDDDDXXXXXXXX    X",
    "XXXXXX      HXXXXXXXXF   X",
    "XXXXXXVBBBBBBXXBVDVBX    X",
    "XS             B B B     X",
    "XXXXXXBBBBBBB  B B B     X",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX"
]

================
File: levels/level2.py
================
maze_data = [
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XS  V DXXD BVXXXXXXXX   KX",
    "XXXX  DXXDVB BBBBBBBBBXXXX",
    "XXDB XXXXXXXXXXXXBBBBBBBXX",
    "XXDB BBBBBBBXXXXXXXXXF  XX",
    "XXXXXXXBBBBBBBBBBBBXXXXDXX",
    "XXXXXXXXXXXXXXXXBBBXXXBBXX",
    "XXXXXXXXXXXXXXF    XXXBBBX",
    "XXXXXXXXXXXBDBDBDBDXXXF  X",
    "XXXXXXXXXXXXH      XXBBBXX",
    "XXXXXXXXXXXBBXXDDXXXXDBXXX",
    "XXXXBBF      XXXXXXXXBDXXX",
    "XXVBBBBBBBBXXXXXXXXXXDBXXX",
    "XX  H  XXXXXXXXXXXVXXBXXXX",
    "XX XDDDDXXXXXXXXXX BBBXXXX",
    "XX XXXXXXXXXXXXXXX BBXXXXX",
    "XX BBXXDDDDDDXXXXX BXXXXXX",
    "XXXBBBBH     BBBBBBXXXXXXX",
    "XXXDDXXBBBBBBXXXXXXXXXXXXX",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX"
]

================
File: README.md
================
# Diamond Bullet

Diamond Bullet is a hybrid game that combines elements from Diamond Rush and Mr. Bullet. Players navigate through mazes to collect bullets and then use those bullets to eliminate enemies in a physics-based puzzle environment. The game features increasing levels of difficulty, various challenges, and obstacles.

## Table of Contents


## Features

- **Maze Navigation**: Players control a character to navigate through mazes, collecting bullets scattered throughout the levels.
- **Puzzle Shooting**: Once the player finds the way out of the maze, they enter a shooting phase where they must eliminate enemies using the collected bullets.
- **Challenges and Obstacles**: Each level introduces new challenges and obstacles, requiring strategic thinking and precise aiming.
- **Audio and Visual Effects**: Background music, sound effects, and visual effects enhance the gaming experience.

================
File: src/bush.py
================
import pygame

class Bush(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.image.load('../assets/graphics/bush.png').convert_alpha()
        self.image = pygame.transform.smoothscale(self.image, (32, 32))
        self.rect = self.image.get_rect(topleft=(x, y))

================
File: src/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: src/diamond.py
================
import pygame

class Diamond(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.image.load('../assets/graphics/diamond.png').convert_alpha()
        self.image = pygame.transform.smoothscale(self.image, (32, 32))
        self.rect = self.image.get_rect(topleft=(x, y))

================
File: src/fire.py
================
import pygame

class Fire(pygame.sprite.Sprite):
    def __init__(self, x, y, initial_pos):
        super().__init__()
        self.image = pygame.image.load('../assets/graphics/fire.png').convert_alpha()
        self.image = pygame.transform.smoothscale(self.image, (32, 32))
        self.rect = self.image.get_rect(topleft=(x, y))
        self.initial_pos = initial_pos
        self.timer = 0
        self.spreading = True

    def update(self, walls, fire_group):
        self.timer += 1
        if self.timer >= 60:  # Spread every second
            self.timer = 0
            if self.spreading:
                next_pos = self.rect.move(32, 0)
                temp_sprite = pygame.sprite.Sprite()
                temp_sprite.rect = next_pos
                if pygame.sprite.spritecollideany(temp_sprite, walls):
                    self.spreading = False
                    # Remove all fires in the current line
                    for fire in fire_group:
                        if fire.rect.y == self.rect.y:
                            fire_group.remove(fire)
                    # Restart the cycle with the original fire
                    fire_group.add(Fire(self.initial_pos[0], self.initial_pos[1], self.initial_pos))
                else:
                    new_fire = Fire(next_pos.x, next_pos.y, self.initial_pos)
                    fire_group.add(new_fire)

================
File: src/game.py
================
import pygame
import sys
from maze import Maze
from player import Player

pygame.init()

WIDTH, HEIGHT = 832, 672
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Diamond Rush")
clock = pygame.time.Clock()

current_level = 1
maze = Maze(WIDTH, HEIGHT, current_level)
player = Player(maze.start_pos[0], maze.start_pos[1], 32)

start_screen = True
end_screen = False
score = 0
font = pygame.font.Font('../assets/font/Pixeltype.ttf', 36)
diamond_image = pygame.image.load('../assets/graphics/diamond.png').convert_alpha()
text_height = font.get_height()
diamond_image = pygame.transform.smoothscale(diamond_image, (text_height, text_height))

# Load diamond collect sound
point_collect_sound = pygame.mixer.Sound('../assets/sounds/point_collect.wav')

def draw_score():
    score_text = font.render(f"Score: {score}", False, (255, 255, 255))
    screen.blit(diamond_image, (10, 10))
    screen.blit(score_text, (10 + text_height + 10, 10))

def draw_start_screen():
    start_text = font.render("Press SPACE to Play", False, (255, 255, 255))
    text_rect = start_text.get_rect(center=(WIDTH // 2, HEIGHT // 2))
    screen.blit(start_text, text_rect)

def draw_end_screen():
    if player.rect.collidepoint(maze.end_pos):
        if current_level < 2:
            end_text = font.render(f"Level {current_level} Complete! Score: {score}", False, (255, 255, 255))
            text_rect = end_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 50))
            screen.blit(end_text, text_rect)

            next_level_text = font.render(f"Press SPACE to Move to Level {current_level + 1}", False, (255, 255, 255))
            text_rect = next_level_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 50))
            screen.blit(next_level_text, text_rect)
        else:
            end_text = font.render(f"Congratulations! You've completed all levels!", False, (255, 255, 255))
            text_rect = end_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 100))
            screen.blit(end_text, text_rect)

            score_text = font.render(f"Final Score: {score}", False, (255, 255, 255))
            text_rect = score_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 50))
            screen.blit(score_text, text_rect)

            thank_you_text = font.render("Thank you for playing!", False, (255, 255, 255))
            text_rect = thank_you_text.get_rect(center=(WIDTH // 2, HEIGHT // 2))
            screen.blit(thank_you_text, text_rect)

            restart_text = font.render("Press SPACE to Start from Level 1", False, (255, 255, 255))
            text_rect = restart_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 50))
            screen.blit(restart_text, text_rect)
    else:
        end_text = font.render(f"Game Over! Score: {score}", False, (255, 255, 255))
        text_rect = end_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 50))
        screen.blit(end_text, text_rect)

        restart_text = font.render("Press SPACE to Restart", False, (255, 255, 255))
        text_rect = restart_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 50))
        screen.blit(restart_text, text_rect)

def draw_restart_message():
    restart_text = font.render("Press R to Restart", False, (255, 255, 255))
    text_rect = restart_text.get_rect(center=(WIDTH // 2, HEIGHT - 30))
    screen.blit(restart_text, text_rect)

def reset_game():
    global player, score, start_screen, end_screen, current_level, maze
    if player.rect.collidepoint(maze.end_pos):
        if current_level < 2:
            current_level += 1
        else:
            current_level = 1
    maze = Maze(WIDTH, HEIGHT, current_level)
    player = Player(maze.start_pos[0], maze.start_pos[1], 32)
    score = 0
    start_screen = False
    end_screen = False

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE and (start_screen or end_screen):
                reset_game()
            elif event.key == pygame.K_r:
                reset_game()

            if event.key in [pygame.K_RIGHT, pygame.K_LEFT, pygame.K_UP, pygame.K_DOWN]:
                pos = player.rect.center
                player.player_input(event.key)
                if pygame.sprite.spritecollide(player, maze.walls, dokill=False):
                    player.rect.center = pos

    screen.fill((0, 0, 0))

    if start_screen:
        draw_start_screen()
    elif end_screen:
        draw_end_screen()
    else:
        maze.draw(screen)
        player.draw(screen)

        # Update snakes and fire
        maze.update_snakes()
        maze.update_fires()

        # Check for collisions with diamonds
        if pygame.sprite.spritecollide(player, maze.diamonds, dokill=True):
            score += 1
            point_collect_sound.play()

        # Check for collisions with snakes
        if pygame.sprite.spritecollide(player, maze.snakes, dokill=False):
            end_screen = True

        # Check for collisions with fire
        if pygame.sprite.spritecollide(player, maze.fires, dokill=False):
            end_screen = True

        # Check for collisions with bushes
        if pygame.sprite.spritecollide(player, maze.bushes, dokill=True):
            pass  # Handle bush breaking logic here

        # Check if the player reaches the end point
        if player.rect.collidepoint(maze.end_pos):
            end_screen = True

        draw_score()
        draw_restart_message()

    pygame.display.update()
    clock.tick(60)

================
File: src/maze_data.py
================
maze_data = [    # 26 x 21
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXBBDBBBXXXXDBBBBDBBBBDX",
    "XXXBBBBDDBXXXXDD   X   DDX",
    "XXXVBBDXH  XXXXDD     DDXX",
    "XXX BBBDBBBXXXXXDBBBBBDXXX",
    "XXX BXBBBBBXXXXXXF    XXXX",
    "XXX BBBBXBBBBBBBXX   XXXXX",
    "XXBDBBBBBBBXXXXBXXX XXXXXX",
    "XXBXBBXXXXXXXXXBXXX XXXXXX",
    "XXBBBBBBBBBBBBX         KX",
    "XXXXBBBBXXXXXDXXXXXXXXXXXX",
    "XXXXXXXXXXXXX BBBBBBBBBXXX",
    "XXXXXXXXXXXXXV          XX",
    "XXXXXXXXXXXXX XXF        X",
    "XXXXXXXDDDDDDXXXXXXXX    X",
    "XXXXXX      HXXXXXXXXF   X",
    "XXXXXXVBBBBBBXXBVDVBX    X",
    "XS             B B B     X",
    "XXXXXXBBBBBBB  B B B     X",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX"
]

================
File: src/maze.py
================
import pygame
from wall import Wall
from diamond import Diamond
from snake import Snake
from fire import Fire
from bush import Bush
import importlib.util
import sys
import os

class Maze:
    def __init__(self, width, height, level):
        self.width = width
        self.height = height
        self.walls = pygame.sprite.Group()
        self.diamonds = pygame.sprite.Group()
        self.snakes = pygame.sprite.Group()
        self.fires = pygame.sprite.Group()
        self.bushes = pygame.sprite.Group()
        self.start_pos = None
        self.end_pos = None
        self.background_image = pygame.image.load('../assets/graphics/grass.png').convert()
        self.background_image = pygame.transform.scale(self.background_image, (width, height))
        self.point_image = pygame.image.load('../assets/graphics/point.png').convert_alpha()
        self.point_image = pygame.transform.smoothscale(self.point_image, (32, 32))
        self.load_level(level)

    def load_level(self, level):
        # Construct the path to the level file
        level_file_path = os.path.join(os.path.dirname(__file__), f'../levels/level{level}.py')

        # Load the level module
        spec = importlib.util.spec_from_file_location(f'level{level}', level_file_path)
        level_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(level_module)

        self.maze_data = level_module.maze_data
        self.create_maze()

    def create_maze(self):
        wall_image = pygame.image.load('../assets/graphics/stone.png')
        wall_image = pygame.transform.smoothscale(wall_image, (32, 32))

        for row_index, row in enumerate(self.maze_data):
            for col_index, cell in enumerate(row):
                x = col_index * 32
                y = row_index * 32

                if cell == 'X':
                    wall = Wall(x, y, 32, 32, wall_image)
                    self.walls.add(wall)
                elif cell == 'D':
                    diamond = Diamond(x, y)
                    self.diamonds.add(diamond)
                elif cell == 'V':
                    snake = Snake(x, y, 'vertical_down')
                    self.snakes.add(snake)
                elif cell == 'H':
                    snake = Snake(x, y, 'horizontal_left')
                    self.snakes.add(snake)
                elif cell == 'F':
                    fire = Fire(x, y, (x, y))
                    self.fires.add(fire)
                elif cell == 'B':
                    bush = Bush(x, y)
                    self.bushes.add(bush)
                elif cell == 'S':
                    self.start_pos = (x, y)
                elif cell == 'K':
                    self.end_pos = (x, y)

    def draw(self, screen):
        screen.blit(self.background_image, (0, 0))
        self.walls.draw(screen)
        self.diamonds.draw(screen)
        self.snakes.draw(screen)
        self.fires.draw(screen)
        self.bushes.draw(screen)

        # Draw start and end points
        if self.start_pos:
            screen.blit(self.point_image, self.start_pos)
        if self.end_pos:
            screen.blit(self.point_image, self.end_pos)

    def update_snakes(self):
        for snake in self.snakes:
            snake.update(self.walls, self.bushes, self.diamonds)

    def update_fires(self):
        for fire in self.fires:
            fire.update(self.walls, self.fires)

    def reset(self):
        self.walls.empty()
        self.diamonds.empty()
        self.snakes.empty()
        self.fires.empty()
        self.bushes.empty()
        self.create_maze()

================
File: src/player.py
================
import pygame

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y, speed):
        super().__init__()
        player_image = pygame.image.load('../assets/graphics/Player/player_walk_1.png').convert_alpha()
        player_image = pygame.transform.smoothscale(player_image, (32, 32))

        self.image = player_image
        self.rect = self.image.get_rect(topleft=(x, y))
        self.speed = speed
        self.game_active = False

    def player_input(self, dir):
        if dir == pygame.K_RIGHT:
            self.rect.x += self.speed
            self.moving = True
        elif dir == pygame.K_LEFT:
            self.rect.x -= self.speed
            self.moving = True
        elif dir == pygame.K_UP:
            self.rect.y -= self.speed
            self.moving = True
        elif dir == pygame.K_DOWN:
            self.rect.y += self.speed
            self.moving = True

    def update(self):
        self.player_input()
        keys = pygame.key.get_pressed()
        if not any(keys):
            self.moving = False

    def draw(self, screen):
        screen.blit(self.image, self.rect)

================
File: src/snake.py
================
import pygame

class Snake(pygame.sprite.Sprite):
    def __init__(self, x, y, direction):
        super().__init__()
        self.direction = direction
        self.speed = 32
        self.timer = 0
        self.load_images()
        self.image = self.images[self.direction]
        self.rect = self.image.get_rect(topleft=(x, y))

    def load_images(self):
        self.images = {
            'vertical_down': pygame.image.load('../assets/graphics/snake/snake_down.png').convert_alpha(),
            'vertical_up': pygame.transform.flip(pygame.image.load('../assets/graphics/snake/snake_down.png').convert_alpha(), False, True),
            'horizontal_right': pygame.image.load('../assets/graphics/snake/snake_left.png').convert_alpha(),
            'horizontal_left': pygame.transform.flip(pygame.image.load('../assets/graphics/snake/snake_left.png').convert_alpha(), True, False)
        }
        for key in self.images:
            self.images[key] = pygame.transform.smoothscale(self.images[key], (32, 32))

    def update(self, walls, bushes, diamonds):
        self.timer += 1
        if self.timer >= 60:  # Move every second
            self.timer = 0
            next_pos = self.rect.move(0, self.speed) if self.direction in ['vertical_down', 'vertical_up'] else self.rect.move(self.speed, 0)
            temp_sprite = pygame.sprite.Sprite()
            temp_sprite.rect = next_pos
            if pygame.sprite.spritecollideany(temp_sprite, walls) or pygame.sprite.spritecollideany(temp_sprite, bushes) or pygame.sprite.spritecollideany(temp_sprite, diamonds):
                self.flip_direction()
                next_pos = self.rect.move(0, self.speed) if self.direction in ['vertical_down', 'vertical_up'] else self.rect.move(self.speed, 0)
            self.rect = next_pos

    def flip_direction(self):
        if self.direction == 'vertical_down':
            self.direction = 'vertical_up'
            self.speed = -32
        elif self.direction == 'vertical_up':
            self.direction = 'vertical_down'
            self.speed = 32
        elif self.direction == 'horizontal_left':
            self.direction = 'horizontal_right'
            self.speed = -32
        elif self.direction == 'horizontal_right':
            self.direction = 'horizontal_left'
            self.speed = 32
        self.image = self.images[self.direction]

================
File: src/wall.py
================
import pygame

class Wall(pygame.sprite.Sprite):
    def __init__(self, x, y, width, height, image):
        super().__init__()
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
