This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-02T21:59:32.302Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/desktop.ini
assets/desktop.ini
assets/font/desktop.ini
assets/graphics/desktop.ini
assets/graphics/Player/desktop.ini
assets/graphics/snake/desktop.ini
assets/sounds/desktop.ini
desktop.ini
levels/desktop.ini
levels/level1.py
levels/level2.py
README.md
src/bush.py
src/desktop.ini
src/diamond.py
src/fire.py
src/game.py
src/maze_data.py
src/maze.py
src/player.py
src/snake.py
src/wall.py

================================================================
Repository Files
================================================================

================
File: .github/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/font/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/graphics/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/graphics/Player/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/graphics/snake/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: assets/sounds/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: levels/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: levels/level1.py
================
maze_data = [    # 26 x 21
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXBBDBBBXXXXDBBBBDBBBBDX",
    "XXXBBBBDDBXXXXDD   X   DDX",
    "XXXVBBDXH  XXXXDD     DDXX",
    "XXX BBBDBBBXXXXXDBBBBBDXXX",
    "XXX BXBBBBBXXXXXXF    XXXX",
    "XXX BBBBXBBBBBBBXX   XXXXX",
    "XXBDBBBBBBBXXXXBXXX XXXXXX",
    "XXBXBBXXXXXXXXXBXXX XXXXXX",
    "XXBBBBBBBBBBBBXBBBB    KXX",
    "XXXXBBBBXXXXXDXXXXXXXXXXXX",
    "XXXXXXXXXXXXX BBBBBBBBBXXX",
    "XXXXXXXXXXXXXV          XX",
    "XXXXXXXXXXXXX XXF        X",
    "XXXXXXXDDDDDDXXXXXXXX    X",
    "XXXXXX      HXXXXXXXXF   X",
    "XXXXXXVBBBBBBXXBVDVBX    X",
    "XS             B B B     X",
    "XXXXXXBBBBBBB  B B B     X",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX"
]

================
File: levels/level2.py
================
maze_data = [
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XS  V DXXD BVXXXXXXXX   KX",
    "XXXX  DXXDVB BBBBBBBBBXXXX",
    "XXDB XXXXXXXXXXXXBBBBBBBXX",
    "XXDB BBBBBBBXXXXXXXXXF  XX",
    "XXXXXXXBBBBBBBBBBBBXXXXDXX",
    "XXXXXXXXXXXXXXXXBBBXXXBBXX",
    "XXXXXXXXXXXXXXF    XXXBBBX",
    "XXXXXXXXXXXBDBDBDBDXXXF  X",
    "XXXXXXXXXXXXH      XXBBBXX",
    "XXXXXXXXXXXBBXXDDXXXXDBXXX",
    "XXXXBBF      XXXXXXXXBDXXX",
    "XXVBBBBBBBBXXXXXXXXXXDBXXX",
    "XX  H  XXXXXXXXXXXVXXBXXXX",
    "XX XDDDDXXXXXXXXXX BBBXXXX",
    "XX XXXXXXXXXXXXXXX BBXXXXX",
    "XX BBXXDDDDDDXXXXX BXXXXXX",
    "XXXBBBBH     BBBBBBXXXXXXX",
    "XXXDDXXBBBBBBXXXXXXXXXXXXX",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX"
]

================
File: README.md
================
#Diamond Dash
CS110 Final Project Fall, 2024

##Team Members
- Kushal Padshala
- kpadshala@bignhamton.edu

##Project Description
Introducing Diamond Dash, in this game you control a character who must navigate through complex mazes, collecting diamonds while avoiding hazards like snakes and fires. With multiple levels that increase in difficulty, Diamond Dash provides a fun and challenging experience. Your mission? Collect as many diamonds as possible while making your way to the end of each maze.

##GUI Design
###Initial Design


###Final Design


##Program DesignAAAAA
###Features
- Maze Navigation: Control your character to navigate through various mazes, picking up diamonds along the way.
- Obstacle Avoidance: Be mindful of snakes and fires that move and spread, requiring quick thinking and strategic planning.
- Multiple Levels: Enjoy a variety of levels with increasing difficulty, each featuring unique maze layouts and challenges.
- Score Tracking: Keep track of your score based on the number of diamonds you collect.
- Interactive Start and End Screens: Receive clear instructions and feedback through interactive start and end screens.

##Classes
- Bush: Represents bushes in the game. These are static obstacles that you can pass through without any issues.
- Diamond: Represents diamonds in the game. Collect these to boost your score!
- Fire: Represents fire in the game. Fire spreads over time and can harm you if you touch it, so be careful!
- Maze: Represents the maze in the game. This class handles creating and drawing the maze, as well as updating dynamic elements like snakes and fires.
- Player: Represents you, the player! This class manages your movement and interactions within the game world.
- Snake: Represents snakes in the game. Snakes move in specific directions and change course when they hit obstacles.
- Wall: Represents walls in the game. These are static obstacles that you can't pass through.

##ATP (Acceptance Test Procedure)
| Step | Description |  Results |
|------|-----------|------------------|
| 1    | Run the Game | The start screen appears with the game logo and instructions to press SPACE to play. |
| 2    | Press SPACE on the Start Screen | The game begins, and your character appears at the starting position in the maze. |
| 3    | Use Arrow Keys to Move the Player | Your character moves in the corresponding direction. |
| 4    | Collect a Diamond | Your score increases by 1, and a sound effect plays. |
| 5    | Encounter a Snake or Fire | The game ends, and the end screen appears with your score and instructions to press SPACE to restart. |
| 6    | Reach the End of the Maze | The level is completed, and the end screen appears with your score and instructions to press SPACE to move to the next level. |
| 7    | Press SPACE on the End Screen | The game resets, and the next level begins (or the game restarts from level 1 if all levels are completed). |
| 8    | Press R During Gameplay | The game resets, and the player starts from the beginning of the current level. |

================
File: src/bush.py
================
import pygame

class Bush(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.image.load('../assets/graphics/bush.png').convert_alpha()
        self.image = pygame.transform.smoothscale(self.image, (32, 32))
        self.rect = self.image.get_rect(topleft=(x, y))

================
File: src/desktop.ini
================
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\100.0.2.0\GoogleDriveFS.exe,26

================
File: src/diamond.py
================
import pygame

class Diamond(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.image.load('../assets/graphics/diamond.png').convert_alpha()
        self.image = pygame.transform.smoothscale(self.image, (32, 32))
        self.rect = self.image.get_rect(topleft=(x, y))

================
File: src/fire.py
================
import pygame

class Fire(pygame.sprite.Sprite):
    def __init__(self, x, y, initial_pos):
        super().__init__()
        self.image = pygame.image.load('../assets/graphics/fire.png').convert_alpha()
        self.image = pygame.transform.smoothscale(self.image, (32, 32))
        self.rect = self.image.get_rect(topleft=(x, y))
        self.initial_pos = initial_pos
        self.timer = 0
        self.spreading = True

    def update(self, walls, fire_group):
        self.timer += 1
        if self.timer >= 60:  # Spread every second
            self.timer = 0
            if self.spreading:
                next_pos = self.rect.move(32, 0)
                temp_sprite = pygame.sprite.Sprite()
                temp_sprite.rect = next_pos
                if pygame.sprite.spritecollideany(temp_sprite, walls):
                    self.spreading = False
                    # Remove all fires in the current line
                    for fire in fire_group:
                        if fire.rect.y == self.rect.y:
                            fire_group.remove(fire)
                    # Restart the cycle with the original fire
                    fire_group.add(Fire(self.initial_pos[0], self.initial_pos[1], self.initial_pos))
                else:
                    new_fire = Fire(next_pos.x, next_pos.y, self.initial_pos)
                    fire_group.add(new_fire)

================
File: src/game.py
================
import pygame
import sys
from maze import Maze
from player import Player

pygame.init()

WIDTH, HEIGHT = 832, 672
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Diamond Dash")
clock = pygame.time.Clock()

current_level = 1
maze = Maze(WIDTH, HEIGHT, current_level)
player = Player(maze.start_pos[0], maze.start_pos[1], 32)

start_screen = True
end_screen = False
score = 0
font = pygame.font.Font('../assets/font/Pixeltype.ttf', 36)
diamond_image = pygame.image.load('../assets/graphics/diamond.png').convert_alpha()
text_height = font.get_height()
diamond_image = pygame.transform.smoothscale(diamond_image, (text_height, text_height))

point_collect_sound = pygame.mixer.Sound('../assets/sounds/point_collect.wav')

logo_image = pygame.image.load('../assets/graphics/logo.png').convert_alpha()
logo_image = pygame.transform.smoothscale(logo_image, (200, 200))  

def draw_score():
    score_text = font.render(f"Score: {score}", False, (255, 255, 255))
    screen.blit(diamond_image, (10, 10))
    screen.blit(score_text, (10 + text_height + 10, 10))

def draw_start_screen():
    logo_rect = logo_image.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 100))
    screen.blit(logo_image, logo_rect)

    start_text = font.render("Press SPACE to Play", False, (255, 255, 255))
    text_rect = start_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 50))
    screen.blit(start_text, text_rect)

def draw_end_screen():
    if player.rect.collidepoint(maze.end_pos):
        if current_level < 2:
            end_text = font.render(f"Level {current_level} Complete! Score: {score}", False, (255, 255, 255))
            text_rect = end_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 50))
            screen.blit(end_text, text_rect)

            next_level_text = font.render(f"Press SPACE to Move to Level {current_level + 1}", False, (255, 255, 255))
            text_rect = next_level_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 50))
            screen.blit(next_level_text, text_rect)
        else:
            end_text = font.render(f"Congratulations! You've completed all levels!", False, (255, 255, 255))
            text_rect = end_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 100))
            screen.blit(end_text, text_rect)

            score_text = font.render(f"Final Score: {score}", False, (255, 255, 255))
            text_rect = score_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 50))
            screen.blit(score_text, text_rect)

            thank_you_text = font.render("Thank you for playing!", False, (255, 255, 255))
            text_rect = thank_you_text.get_rect(center=(WIDTH // 2, HEIGHT // 2))
            screen.blit(thank_you_text, text_rect)

            restart_text = font.render("Press SPACE to Start from Level 1", False, (255, 255, 255))
            text_rect = restart_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 50))
            screen.blit(restart_text, text_rect)
    else:
        end_text = font.render(f"Game Over! Score: {score}", False, (255, 255, 255))
        text_rect = end_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 50))
        screen.blit(end_text, text_rect)

        restart_text = font.render("Press SPACE to Restart", False, (255, 255, 255))
        text_rect = restart_text.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 50))
        screen.blit(restart_text, text_rect)

def draw_restart_message():
    restart_text = font.render("Press R to Restart", False, (255, 255, 255))
    text_rect = restart_text.get_rect(center=(WIDTH // 2, HEIGHT - 30))
    screen.blit(restart_text, text_rect)

def reset_game():
    global player, score, start_screen, end_screen, current_level, maze
    if player.rect.collidepoint(maze.end_pos):
        if current_level < 2:
            current_level += 1
        else:
            current_level = 1
    maze = Maze(WIDTH, HEIGHT, current_level)
    player = Player(maze.start_pos[0], maze.start_pos[1], 32)
    score = 0
    start_screen = False
    end_screen = False

# this is your main loop
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE and (start_screen or end_screen):
                reset_game()
            elif event.key == pygame.K_r:
                reset_game()

            if event.key in [pygame.K_RIGHT, pygame.K_LEFT, pygame.K_UP, pygame.K_DOWN]:
                pos = player.rect.center
                player.player_input(event.key)
                if pygame.sprite.spritecollide(player, maze.walls, dokill=False):
                    player.rect.center = pos

    screen.fill((0, 0, 0))

    if start_screen:
        draw_start_screen()
    elif end_screen:
        draw_end_screen()
    else:
        maze.draw(screen)
        player.draw(screen)

        maze.update_snakes()
        maze.update_fires()

        if pygame.sprite.spritecollide(player, maze.diamonds, dokill=True):
            score += 1
            point_collect_sound.play()

        if pygame.sprite.spritecollide(player, maze.snakes, dokill=False):
            end_screen = True

        if pygame.sprite.spritecollide(player, maze.fires, dokill=False):
            end_screen = True

        if pygame.sprite.spritecollide(player, maze.bushes, dokill=True):
            pass  

        if player.rect.collidepoint(maze.end_pos):
            end_screen = True

        draw_score()
        draw_restart_message()

    pygame.display.update()
    clock.tick(60)

================
File: src/maze_data.py
================
maze_data = [    # 26 x 21
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXBBDBBBXXXXDBBBBDBBBBDX",
    "XXXBBBBDDBXXXXDD   X   DDX",
    "XXXVBBDXH  XXXXDD     DDXX",
    "XXX BBBDBBBXXXXXDBBBBBDXXX",
    "XXX BXBBBBBXXXXXXF    XXXX",
    "XXX BBBBXBBBBBBBXX   XXXXX",
    "XXBDBBBBBBBXXXXBXXX XXXXXX",
    "XXBXBBXXXXXXXXXBXXX XXXXXX",
    "XXBBBBBBBBBBBBX         KX",
    "XXXXBBBBXXXXXDXXXXXXXXXXXX",
    "XXXXXXXXXXXXX BBBBBBBBBXXX",
    "XXXXXXXXXXXXXV          XX",
    "XXXXXXXXXXXXX XXF        X",
    "XXXXXXXDDDDDDXXXXXXXX    X",
    "XXXXXX      HXXXXXXXXF   X",
    "XXXXXXVBBBBBBXXBVDVBX    X",
    "XS             B B B     X",
    "XXXXXXBBBBBBB  B B B     X",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX",
    "XXXXXXXXXXXXXXXXXXXXXXXXXX"
]

================
File: src/maze.py
================
import pygame
from wall import Wall
from diamond import Diamond
from snake import Snake
from fire import Fire
from bush import Bush
import importlib.util
import sys
import os

class Maze:
    def __init__(self, width, height, level):
        self.width = width
        self.height = height
        self.walls = pygame.sprite.Group()
        self.diamonds = pygame.sprite.Group()
        self.snakes = pygame.sprite.Group()
        self.fires = pygame.sprite.Group()
        self.bushes = pygame.sprite.Group()
        self.start_pos = None
        self.end_pos = None
        self.background_image = pygame.image.load('../assets/graphics/grass.png').convert()
        self.background_image = pygame.transform.scale(self.background_image, (width, height))
        self.point_image = pygame.image.load('../assets/graphics/point.png').convert_alpha()
        self.point_image = pygame.transform.smoothscale(self.point_image, (32, 32))
        self.load_level(level)

    def load_level(self, level):
        # Construct the path to the level file
        level_file_path = os.path.join(os.path.dirname(__file__), f'../levels/level{level}.py')

        # Load the level module
        spec = importlib.util.spec_from_file_location(f'level{level}', level_file_path)
        level_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(level_module)

        self.maze_data = level_module.maze_data
        self.create_maze()

    def create_maze(self):
        wall_image = pygame.image.load('../assets/graphics/stone.png')
        wall_image = pygame.transform.smoothscale(wall_image, (32, 32))

        for row_index, row in enumerate(self.maze_data):
            for col_index, cell in enumerate(row):
                x = col_index * 32
                y = row_index * 32

                if cell == 'X':
                    wall = Wall(x, y, 32, 32, wall_image)
                    self.walls.add(wall)
                elif cell == 'D':
                    diamond = Diamond(x, y)
                    self.diamonds.add(diamond)
                elif cell == 'V':
                    snake = Snake(x, y, 'vertical_down')
                    self.snakes.add(snake)
                elif cell == 'H':
                    snake = Snake(x, y, 'horizontal_left')
                    self.snakes.add(snake)
                elif cell == 'F':
                    fire = Fire(x, y, (x, y))
                    self.fires.add(fire)
                elif cell == 'B':
                    bush = Bush(x, y)
                    self.bushes.add(bush)
                elif cell == 'S':
                    self.start_pos = (x, y)
                elif cell == 'K':
                    self.end_pos = (x, y)

    def draw(self, screen):
        screen.blit(self.background_image, (0, 0))
        self.walls.draw(screen)
        self.diamonds.draw(screen)
        self.snakes.draw(screen)
        self.fires.draw(screen)
        self.bushes.draw(screen)

        # Draw start and end points
        if self.start_pos:
            screen.blit(self.point_image, self.start_pos)
        if self.end_pos:
            screen.blit(self.point_image, self.end_pos)

    def update_snakes(self):
        for snake in self.snakes:
            snake.update(self.walls, self.bushes, self.diamonds)

    def update_fires(self):
        for fire in self.fires:
            fire.update(self.walls, self.fires)

    def reset(self):
        self.walls.empty()
        self.diamonds.empty()
        self.snakes.empty()
        self.fires.empty()
        self.bushes.empty()
        self.create_maze()

================
File: src/player.py
================
import pygame

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y, speed):
        super().__init__()
        player_image = pygame.image.load('../assets/graphics/Player/player_walk_1.png').convert_alpha()
        player_image = pygame.transform.smoothscale(player_image, (32, 32))

        self.image = player_image
        self.rect = self.image.get_rect(topleft=(x, y))
        self.speed = speed
        self.game_active = False

    def player_input(self, dir):
        if dir == pygame.K_RIGHT:
            self.rect.x += self.speed
            self.moving = True
        elif dir == pygame.K_LEFT:
            self.rect.x -= self.speed
            self.moving = True
        elif dir == pygame.K_UP:
            self.rect.y -= self.speed
            self.moving = True
        elif dir == pygame.K_DOWN:
            self.rect.y += self.speed
            self.moving = True

    def update(self):
        self.player_input()
        keys = pygame.key.get_pressed()
        if not any(keys):
            self.moving = False

    def draw(self, screen):
        screen.blit(self.image, self.rect)

================
File: src/snake.py
================
import pygame

class Snake(pygame.sprite.Sprite):
    def __init__(self, x, y, direction):
        super().__init__()
        self.direction = direction
        self.speed = 32
        self.timer = 0
        self.load_images()
        self.image = self.images[self.direction]
        self.rect = self.image.get_rect(topleft=(x, y))

    def load_images(self):
        self.images = {
            'vertical_down': pygame.image.load('../assets/graphics/snake/snake_down.png').convert_alpha(),
            'vertical_up': pygame.transform.flip(pygame.image.load('../assets/graphics/snake/snake_down.png').convert_alpha(), False, True),
            'horizontal_right': pygame.image.load('../assets/graphics/snake/snake_left.png').convert_alpha(),
            'horizontal_left': pygame.transform.flip(pygame.image.load('../assets/graphics/snake/snake_left.png').convert_alpha(), True, False)
        }
        for key in self.images:
            self.images[key] = pygame.transform.smoothscale(self.images[key], (32, 32))

    def update(self, walls, bushes, diamonds):
        self.timer += 1
        if self.timer >= 60:  # Move every second
            self.timer = 0
            next_pos = self.rect.move(0, self.speed) if self.direction in ['vertical_down', 'vertical_up'] else self.rect.move(self.speed, 0)
            temp_sprite = pygame.sprite.Sprite()
            temp_sprite.rect = next_pos
            if pygame.sprite.spritecollideany(temp_sprite, walls) or pygame.sprite.spritecollideany(temp_sprite, bushes) or pygame.sprite.spritecollideany(temp_sprite, diamonds):
                self.flip_direction()
                next_pos = self.rect.move(0, self.speed) if self.direction in ['vertical_down', 'vertical_up'] else self.rect.move(self.speed, 0)
            self.rect = next_pos

    def flip_direction(self):
        if self.direction == 'vertical_down':
            self.direction = 'vertical_up'
            self.speed = -32
        elif self.direction == 'vertical_up':
            self.direction = 'vertical_down'
            self.speed = 32
        elif self.direction == 'horizontal_left':
            self.direction = 'horizontal_right'
            self.speed = -32
        elif self.direction == 'horizontal_right':
            self.direction = 'horizontal_left'
            self.speed = 32
        self.image = self.images[self.direction]

================
File: src/wall.py
================
import pygame

class Wall(pygame.sprite.Sprite):
    def __init__(self, x, y, width, height, image):
        super().__init__()
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
